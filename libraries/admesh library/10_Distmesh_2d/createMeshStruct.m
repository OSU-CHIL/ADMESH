function MESH = createMeshStruct(t,p,MESH,PTS,xyzFun)
% createMeshStruct - Creates a sructure array of mesh data generated by
% distmesh2d
%
% Syntax:  mesh = createMeshStruct(t,p,mesh,PTS,xyzFun)
%
% Inputs:
%    t      - Connectivity List
%    p      - Nodal Points
%    mesh   - Mesh Structure Array
%    PTS    - ADMESH Edge Structure
%    xyzFun - Gridded Interpolant
%
% Outputs:
%    mesh - Sructure Array of Mesh Data
%
% Other m-files required: distmesh2d
% Subfunctions: none
% MAT-files required: none
%
% Author: Dustin West
% The Ohio State University
% email address: dww.425@gmail.com
% Last revision: 25-April-2014

%---------------------------------------------------------------------
% Begin Code
%---------------------------------------------------------------------


%---------------------------------------------------------------------
% If cpplon & cpplat exist add it to mesh structure
%---------------------------------------------------------------------
if isfield(PTS,'cpplon')
    MESH.cpplon = PTS.cpplon;
    MESH.cpplat = PTS.cpplat;
else
    MESH.cpplon = [];
    MESH.cpplat = [];
end

%---------------------------------------------------------------------
% Get NaN seperated boundary list from mesh
%---------------------------------------------------------------------
plist = Mesh2PolyList(t,p);

if ~isempty(MESH.Constraints)
    
    %-----------------------------------------------------------------
    % If open ocean boundaries exist, complete new node strings
    %-----------------------------------------------------------------
    if any(ismember([MESH.Constraints.num],-1))
        
        % Obtain open ocean boundary data
        [NOPE,~,~,NBDV] = GetOpenOceanBC(t,p,PTS);
        
        % Find index in mesh structure to store node string
        ix = find(ismember([MESH.Constraints.num],-1));
        
        for i = 1:NOPE
            
            % Assign node string
            MESH.Constraints(ix(i)).nodeStr = NBDV{i}';
            
        end
        
    end
    
    %-----------------------------------------------------------------
    % Remove constraint node strings from plist
    %-----------------------------------------------------------------
    for k = 1:numel(MESH.Constraints)

        if any(MESH.Constraints(k).num == [4 5 24 25])
            
            str = MESH.Constraints(k).nodeStr;
            
            % If end segments are on mainland border, add back to plist
            xi = [p(str(1,1),1); p(str(1,2),1)];
            yi = [p(str(1,1),2); p(str(1,2),2)];
            
            d = Point2EdgeDistance(xi,yi,PTS.Poly(1).x,PTS.Poly(1).y);
            
            if all(d <= eps)
                
                % Remove from plist
                plist = RemoveFromPlist(p,plist,str(2:end-1,1));
                plist = RemoveFromPlist(p,plist,str(2:end-1,2));
                
                % Add end points to plist
                plist = [plist ;...
                    [nan nan]; ...
                    [xi yi] ;...
                    [nan nan]]; %#ok<AGROW>
                
            else
                
                % Remove from plist
                plist = RemoveFromPlist(p,plist,str(:,1));
                plist = RemoveFromPlist(p,plist,str(:,2));
                
                
            end
            
            % Add ending edge segment
            xi = [p(str(end,1),1); p(str(end,2),1)];
            yi = [p(str(end,1),2); p(str(end,2),2)];
            
            d = Point2EdgeDistance(xi,yi,PTS.Poly(1).x,PTS.Poly(1).y);
            
            if all(d <= eps)
                
                % Remove from plist
                plist = RemoveFromPlist(p,plist,str(2:end-1,1));
                plist = RemoveFromPlist(p,plist,str(2:end-1,2));
                
                % Add end points to plist
                plist = [plist ;...
                    [nan nan]; ...
                    [xi yi] ;...
                    [nan nan]]; %#ok<AGROW>
                
            else
                
                % Remove from plist
                plist = RemoveFromPlist(p,plist,str(:,1));
                plist = RemoveFromPlist(p,plist,str(:,2));
                
            end
            
        else
            
            if MESH.Constraints(k).num ~= [18 19 17]
                
                str = unique(MESH.Constraints(k).nodeStr,'stable');
                
                % Remove from plist
                plist = RemoveFromPlist(p,plist,str(2:end-1));
                
            end
            
        end
        
    end
    
    %-----------------------------------------------------------------
    % store internal and external boundary info
    %-----------------------------------------------------------------
    
    % Join all edge segments possible
    [plist]=join_cst(plist,eps);
    
    % Compile segements into cell array and designate a external or 
    % internal boundary condition
    i1 = all(~isnan(plist),2); i2 = i1(:)';
    idx = [strfind([~i2(1),i2],[0 1]); strfind([i2, ~i2(end)],[1 0])];
    seg = mat2cell(plist(i1,:),diff(idx)+1,size(plist,2));
        
    % Counter for constraint indexing
    n = numel(MESH.Constraints);
    
    nSegments = length(seg);
        
    % Go through each segment. Determine if segment is internal or 
    % external
    for i = 1:nSegments
        
        % vector for comparing distances
        d = zeros(1,length(PTS.Poly));

        % Compute minimum distance to each boundary, find closest 
        % boundary
        for k = 1:length(PTS.Poly)
            
            d(k) = ...
                min(...
                Point2EdgeDistance(...
                seg{i}(:,1),seg{i}(:,2),...
                PTS.Poly(k).x,PTS.Poly(k).y));
            
        end
        
        [~,ix] = min(d); % find minimum distance
        
        if ix == 1 % External boundary
            
            % Assign number associated with constraint
            MESH.Constraints(n+i).num = 0;
            
            % Assign node string type
            MESH.Constraints(n+i).type = 'External Boundary';
            
            % Ensure point list is unique
            if ( ...
                    seg{i}(1,1) == seg{i}(end,1) && ...
                    seg{i}(1,2) == seg{i}(end,2) )
                
                % If boundary is original closed, add end point
                seg{i} = [unique(seg{i},'rows','stable') ; seg{i}(1,:)];
                
            else
                
                seg{i} = unique(seg{i},'rows','stable');
                
            end
            
            
        else % Maybe an Internal boundary
            
            if ( ...
                    seg{i}(1,1) ==  seg{i}(end,1) && ...
                    seg{i}(1,2) == seg{i}(end,2) )
                
                % Assign number associated with constraint
                MESH.Constraints(n+i).num = 1;
                
                % Assign node string type
                MESH.Constraints(n+i).type = 'Internal Boundary';
                
                % Remove double points
                seg{i} = [unique(seg{i},'rows','stable') ; seg{i}(1,:)];
                
            else
                
                % Assign number associated with constraint
                MESH.Constraints(n+i).num = 0;
                
                % Assign node string type
                MESH.Constraints(n+i).type = 'External Boundary';
                
                % Remove double points
                seg{i} = unique(seg{i},'rows','stable');
                
            end
            
        end
        
        % Locate nodal values
        for k = 1:length(seg{i}(:,1))
            
            MESH.Constraints(n+i).nodeStr(k,1) = ...
                find((seg{i}(k,1) == p(:,1) & seg{i}(k,2) == p(:,2)));
            
        end
        
    end
    
else
    
    %-----------------------------------------------------------------
    % store internal and external boundary info
    %-----------------------------------------------------------------
    
    MESH.Constraints = [];

    % Join all edge segments possible
    [plist]=join_cst(plist,eps);
    
    % Compile segements into cell array and designate a external or 
    % internal boundary condition
    i1 = all(~isnan(plist),2); i2 = i1(:)';
    idx = [strfind([~i2(1),i2],[0 1]); strfind([i2, ~i2(end)],[1 0])];
    seg = mat2cell(plist(i1,:),diff(idx)+1,size(plist,2));
    
    area = zeros(numel(seg),1);
    
    % order segments based on areas
    for k = 1:length(seg)
       
        area(k) = polyarea(seg{k}(:,1), seg{k}(:,2));
        
    end
    
    % Sort in descending order
    [~,i] = sort(area,'descend');
    
    for j = 1:length(seg)
        
        if j == 1 % save mainland data
            
            % Assign number associated with constraint
            MESH.Constraints(j).num = 0;
            
            % Assign node string type
            MESH.Constraints(j).type = 'External Boundary';
            
            % Locate nodal values
            for k = 1:length(seg{i(j)}(:,1))
                
                MESH.Constraints(j).nodeStr(k,1) = find((...
                    seg{i(j)}(k,1) == p(:,1) & ...
                    seg{i(j)}(k,2) == p(:,2)));
                
            end
            
        else
            
            % Assign number associated with constraint
            MESH.Constraints(j).num = 1;
            
            % Assign node string type
            MESH.Constraints(j).type = 'Internal Boundary';
            
            % Locate nodal values
            for k = 1:length(seg{i(j)}(:,1))
                
                MESH.Constraints(j).nodeStr(k,1) = find((...
                    seg{i(j)}(k,1) == p(:,1) & ...
                    seg{i(j)}(k,2) == p(:,2)));
                
            end
            
        end
        
    end
    
end

%---------------------------------------------------------------------
% Assign mesh nodal coordinates
%---------------------------------------------------------------------
MESH.Points = p;

%---------------------------------------------------------------------
% Interpolate elevation values to nodal coordinates
%---------------------------------------------------------------------
if ~isempty(xyzFun)
    
    z = xyzFun(MESH.Points(:,1),MESH.Points(:,2));
    
    z = double(z); % single variable occurs error with inpaint_nans function
    z = inpaint_nans(z); % Somtimes NaN's occur. Interpolate those.
    
    MESH.Points = [MESH.Points(:,[1 2]) z];
    
else
    
    MESH.Points = [MESH.Points(:,[1 2]) zeros(size(MESH.Points,1),1)];
    
end

%---------------------------------------------------------------------
% Assign mesh connectivity
%---------------------------------------------------------------------
MESH.ConnectivityList = t;

%---------------------------------------------------------------------
% Assign element connectivity
%---------------------------------------------------------------------
trep = triangulation(MESH.ConnectivityList,MESH.Points(:,[1,2]));

MESH.ElementConnectivity = neighbors(trep);


end